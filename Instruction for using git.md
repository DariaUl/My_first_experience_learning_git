## 1. Индексация изменений

git add <файл>

Изменения в файле проиндексированы, но не навсегда. Git теперь знает об изменениях.

## 2. Коммит изменений в репозепозитории

git commit - переносит в vim с возможность редактирования  
git commit -m 'Текст коммита'

## 3. История изменений

git log 

**Для более удобного представления делаем конфигурацию:**  
git config --global format.pretty "%h %ad | %s%d [%an]"  
git config --global log.date short

**П:**  
9e0b5ed 2025-01-30 | Added HTML header (HEAD -> main) [Daria]  
7f0fb5f 2025-01-30 | Added standard HTML page tags [Daria]  
f575dac 2025-01-30 | Added h1 tag [Daria]  
5e40df4 2025-01-30 | Initial Commit [Daria]

## 4. Получение старых версий

git checkout <хэш>

git switch <ветка> - переключение м/у ветками  
git switch main - при переключении на ветку main попадаем на ее последнюю версию

## 5. Создание тегов версий

Это необходимо для более простого отката.

**Создание тега:**  
git tag v1  
git log  

**П:**  
1937be0 2025-01-29 | Added HTML header (HEAD -> main, tag: v1) [Daria]
e47633c 2025-01-29 | Added standard HTML page tags [Daria]
42bb985 2025-01-29 | Added h1 tag [Daria]
1c55f66 2025-01-29 | Initial commit [Daria] 

Теги для предыдущих версий: вместо хэша коммита используем обозначение ^.
git checkout v1^

Проверяем содержимое после отката с помощью команды cat <файл>

git tag v1-beta  
git log

**П:**  
7f0fb5f 2025-01-30 | Added standard HTML page tags (tag: v1-beta) [Daria]  
f575dac 2025-01-30 | Added h1 tag [Daria]  
5e40df4 2025-01-30 | Initial Commit [Daria]

**Теперь можно переключаться м/у отмеченными версиями по имени тега:**  
git checkout v1  
git checkout v1-beta

**Просмотр всех доступных тегов:**  
git tag

**Просмотр тегов в log:**  
git log main --all

P.s. метка HEAD показывает коммит, на который переключились.

## 6. Отмена локальных изменений (до индексации)

**Сброс содержимого файла:**  
git restore <файл>

## 7. Отмена проиндексированных изменений (перед коммитом)

Вносим нежелательные изменения в файл. Индексируем изменение.

**Очищение индекса:**  
git restore --staged <файл>

**Восстановление файла до состояния последнего коммита:**  
git restore <файл>

Теперь директория чиста.

## 8. Отмена коммита 

Один из способов - создание нового коммита, отменяющего нежелательные изменения.

Вносим нежелательные изменения в файл. Индексируем изменение с помощью.  
git commit -m "Oops, we didn't want this commit"

**Делаем коммит с новыми изменениями, отменяющими предыдущие:**  
git revert HEAD - переход в vim, где можно отредактировать коммит-сообщение или оставить все как есть.

**П:**  
86364a1 2025-01-29 | Revert "Oops, we didn't want this commit" (HEAD -> main) [Daria]  
6a44bec 2025-01-29 | Oops, we didn't want this commit [Daria]  
9e0b5ed 2025-01-30 | Added HTML header (tag: v1) [Daria]  
7f0fb5f 2025-01-30 | Added standard HTML page tags (tag: v1-beta) [Daria]  
f575dac 2025-01-30 | Added h1 tag [Daria]  
5e40df4 2025-01-30 | Initial Commit [Daria]

Можно отменить любой коммит в истории, указав хэш.

## 9. Удаление коммитов из ветки

Перед удалением стоит последний коммит отметить тегом, чтобы потом его можно было найти.

**П:**  
git tag oops

**Сбрасываем ветку до необходимой точки:**  
git reset --hard <тег или хэш, до которого нужно сбросить>

Параметр --hard указывает, что рабочая директория должна быть приведена к тому состоянию, которое соответствует HEAD-коммиту ветки.

**П:**
git reset --hard v1

Однако даже после удаления коммиты находятся в репозитории.  
**Можно увидеть с помощью параметра --all:**  
git log --all

Т.е. все еще модно на них ссылаться. Остаются до тех пор, пока не будет запущен сборщик мусора.

! Сбос в локальных ветках еще безопасен. Но на удаленных репозиториях нужно быть осторожным.

## 10. Удаление тегов

git tag -d <тег>

**П:**  
git tag -d oops

Тег больше не будет отображаться в репозиториях, даже с параметром --all.

## 11. Внесение изменений в коммиты

git commit --amend -m 'Измененный текст коммита'

**П:**  
git add hello.html - добавление необходимой информации  
git commit --amend -m "Added copyright statement with email" - изменение текста существующего коммита

## 12 . Создание ветки

Можно параллельно работать над несколькими фичами в каждой ветке + до сливания веток, ветка main будет защищена от непроверенного кода.

git switch -c <ветка>

## 13 . Переключение веток

git switch <ветка>

## 14 . Перемещение файлов в пределах репозитория 

**Возможен просмотр истории изменения файла:**  
git log <файл>

**Просмотр различий для конкретного файла:**  
Позволяет увидеть, что именно изменилось, а также кто и когда внес эти изменения. Также существует возможность увидеть изменения, связанные с конкретным коммитом. 
git show <ссылка на коммит> - просмотр изменений в конкретном коммите

Ссылка на коммит может быть: метка HEAD, хэш коммита, имя ветки или тега и т.д.

**Переименование файла:**  
mv <текущее название файла> <новое название файла>

Git воспринимает изменение так, будто файл был удален и создан заново. Нужно сообщить Git, что файл переименовывается, а не удаляется его и сразу создали новый. В простейшем случае Git сам поймёт, что файл был переименован, как только добавим его в индекс:
git add .

**Перемещение файла:**  
mkdir <директория> - перед пермещением создаем директорию  
git mv <файл> <директория>/<файл>

**П:**
mkdir css  
git mv style.css css/style.css  
git status

git commit -m "Renamed hello.html; moved style.css"

git log css/style.css - проверка изменений в файле  

**П:**  
f7f6a35 2025-01-31 | Renamed hello.html; moved style.css (HEAD -> style) [Daria]

git log --follow css/style.css - для просмотра истории файла до его перемещения

**П:**  
f7f6a35 2025-01-31 | Renamed hello.html; moved style.css (HEAD -> style) [Daria]  
28e6882 2025-01-31 | Added css stylesheet [Daria]

## 15. Просмотр отличающихся веток

git log --all --graph - просмотр веток и их расхождения  

Опция --graph добавляет простое дерево коммитов, представленное в виде простых текстовых линий.  
Общим предком для обеих веток является ветка, в которую был внесен коммит «Added copyright statement with email».

## 16. Слияние веток

git switch <целевая ветка> - переключение на ветку, в которую вносятся изменения. Это та ветка, которая будет обновлена  
git merge <источниковая ветка> - выполниние слияние изменений из ветки, из которой берутся изменения

**П:**  
git switch style - в эту ветку вносятся изменения из main  
git merge main - вливаем изменения из ветки main (все изменения, что были в main, будут добавлены в ветку style)  
git log --all --graph